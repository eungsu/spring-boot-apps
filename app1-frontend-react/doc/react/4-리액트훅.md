# 리액트 훅(React Hooks)
- React Hooks는 함수형 컴포넌트에서도 React의 상태 관리(state), 생명주기(lifecycle), side effect, context 등을 사용할 수 있게 해주는 함수 기반 API다.

## 주요 리액트 훅

| 이름 | 정의/역할 | 주요 사용 목적 |
|---|---|---|
| `useState` | 컴포넌트의 내부 상태를 선언하고 관리 | 컴포넌트 상태 선언 및 업데이트 |
| `useEffect` | 컴포넌트 렌더링 후 side effect 실행 | 비동기 작업, 구독, 타이머, clean up 등 |
| `useRef` | DOM 요소 또는 값의 참조를 저장, 리렌더링없이 값 유지 | DOM 접근, 이전 값 저장, focus 제어 |
| `useMemo` | 계산결과를 메모이제이션 (성능 최적화용) | 무거운 연산 캐싱, 리렌더링 최적화 |
| `useCallback` | 함수를 메모이제이션 (불필요한 리렌더링 방지) | 콜백함수 재사용, 자식 컴포넌트에 전달시 최적화 |
| `useContext` | Context 값을 읽어옴 (전역 상태 또는 설정값 등) | 전역 값 접근 (테마, 로그인 정보 등) |
| `useReducer` | 복잡한 상태 로직을 reducer 패턴으로 관리 | 복잡한 상태 관리, Redux 유사 구조 |

* `useState`, `useEffect`, `useRef`, `useMemo` 등이 자주 사용되는 훅이다.

## `useState` 훅
### 정의
- `useState`는 함수형 컴포넌트에서 **상태(State)** 를 관리할 수 있게 해주는 훅이다.
- 컴포넌트 내부에서 시간에 따라 변할 수 있는 데이터를 다루고, 이 데이터가 변경될 때마다 컴포넌트가 자동으로 다시 렌더링되도록 한다.
### 주요 구조
- `useState`는 배열을 반환한다.
- 배열의 첫번째 요소는 **현재 상태 값(State value)** 이다.
- 배열의 두번째 요소는 이 상태 값을 **업데이트하는 함수(Setter 함수)** 다.
  ```javascript
  const [state, setState] = useState(initialState);
  ```
  - `state`: 현재 값을 나타낸다.
  - `setState`:
    - `state`값을 업데이트하는 함수다.
    - 이 함수를 호출해서 State의 현재 값을 변경한다.
    - dl 함수를 호출하면 컴포넌트가 다시 렌더링된다.
  - `initialState`
    - State의 **초기값**이다.
    - 숫자, 문자열, 불린, 객체, 배열 등 다양한 타입이 가능한다.
    - 초기값은 첫 렌더링 시에만 사용된다.
### 주요 API
- 값 업데이트 방식: `setState(newValue)`
  - State 상태를 `newValue`로 직접 업데이트한다.
  - `newValue`는 State의 이전 값과 상관없이 새로운 상태값으로 업데이트한다.
    ```javascript
    // 현재 카운터값을 관리하는 useState를 선언한다.
    const [count, setCount] = useState(0);
    
    // setCount(새카운트값)을 실행해서 State값을 변경한다.
    setCount(count + 1);  // count가 현재 5라면, 6으로 설정한다.
    ```
- 함수형 업데이트 방식: `setState((prevState) => newValue)`
  - 이전 상태값(`prevState`)을 기반으로 새로운 상태값을 계산하여 업데이트할 때 사용한다.
  - `setState` 호출이 비동기적으로 배치(batch)될 수 있으므로, 이전 상태에 의존하는 업데이트에는 함수형 업데이트 방식을 사용하는 것이 안전한다.
    ```javascript
    // 현재 카운터값을 관리하는 useState를 선언한다.
    const [count, setCount] = useState(0);

    // setCount(업데이트함수)를 실행해서 State값을 변경한다.
    setCount(prevCount => prevCount + 1);
    ```
### 사용 목적
- 컴포넌트 내부에서 **시간에 따라 동적으로 변하는 데이터**를 관리해야 할 때 사용된다.
- 사용자 입력(폼입력 데이터), UI의 표시/숨김상태(토글), 백엔드 API로부터 받아온 데이터와 같이 **UI를 업데이트해야하는 모든 동적 데이터의 관리**에 사용한다.
### 사용 예시
#### 단순한 값을 관리하기
  ```jsx
  import React, { useState } from 'react';

  function Counter() {
    // state 선언
    //      useState(초기값)을 실행한다, useState함수는 배열을 반환한다. 배열은 [현재상태값, Setter함수]를 요소로 가진다.
    //      state변수에는 현재 상태값이 대입된다.
    //      setCount변수에는 Setter함수가 대입된다.
    const [count, setCount] = useState(0);

    const handleIncrement = () => {
      setCount(count + 1);  // count값을 1 증가시킨다.
    }

    const handleDecrement = () => {
      // 이전 상태에 기반한 함수형 업덷이트 방식이다.
      setCount(prevCount => prevCount - 1);
    }

    return (
      <div>
        <h1>useState 예제</h1>
        <p>현재 카운터 값: {count}</p>
        <button onClick={handleIncrement}>증가</button>
        <button onClick={handleDecrement}>감소</button>
      </div>
    )
  }
  ```

#### 객체 상태 관리하기
- State가 객체로 상태를 관리할 때는 **불변성**을 유지하면서 업데이트해야 한다.
- 직접 객체를 수정하지 않고, 항상 새로운 객체를 생성하여 반환해야 한다.
- 전개 연산자(`...`)를 사용한다.
  ```javascript
  import React, { useState } from 'react';

  function UserProfile() {
    const [user, setUser] = useState({
      name: "홍길동",
      age: 30,
      email: "hong@gmail.com"
    });

    cont handleNameChange = (e) => {
      // 기존 loginData객체르 복사하고, name만 변경한 새로운 객체를 반환한다.
      setUser({ ...user, name: e.target.value });
    };

    const handleAgeIncrement = () => {
      setUser(prevUser => ({
        ...prevUser,
        age: prevUser.age + 1;
      }))
    };

    return (
      <div>
        <h1>사용자 프로필</h1>
        <p>이름: {user.name}</p>
        <p>나이: {user.age}</p>
        <p>이메일: {user.email}</p>

        <input
          type="text"
          value={user.name}
          onClick={handleNameChange}
        />

        <button onClick={handleAgeIncrement}>나이 증가</button>
      </div>
    );
  }
  ```

#### 배열 상태 관리하기


