# 리액트
- **React**는 **사용자 인터페이스(User interface)** 를 만들기 위한 **JavaScript 라이브러리**다.
- React는 컴포넌트 기반의 선언형 UI 라이브러리이며, 상태에 따라 UI를 효율적으로 업데이트한다.

## 주요 특징
- 선언형 프로그래밍을 지원
  - 상태(state)가 변경되면 UI는 자동으로 업데이트된다.
- 컴포넌트 기반 구조
  - UI를 재사용 가능한 컴포넌트 단위로 나누어서 개발한다.
- Virtual DOM
  - React는 실제 DOM이 아닌 **Virtual DOM**에 변경사항을 먼저 적용하고, 변경된 부분만 실제 DOM에 반영한다.
- 단방향 데이터 흐름
  - React에서 데이터는 **부모 컴포넌트 -> 자식 컴포넌트** 방향으로 전달된다.
- React Hook 지원
  - `useState`, `useEffect`, `useContext` 등 다양한 Hook을 제공한다.
  - Hook은 함수형 컴포넌트에서 React의 상태관리, 생명주기, 기타 기능을 지원하는 특수한 함수다.
- JSX(JavaScript + XML 문법)
  - HTML과 유사한 문법을 JavaScript안에 작성할 수 있게 한다.
  - 개발자가 UI을 쉽게 구성할 수 있게 한다.
 
## JXS(JavaScript XML)
- JSX 문법은 JavaScript 코드 안에서 HTML과 유사한 문법을 사용할 수 있게 해주는 **JavaScript의 확장문법**이다.
- JSX는 리액트에서 **UI를 선언형 방식으로 표현**할 수 있어서 가독성과 유지보수성이 좋아진다.

### 사용시 주의할 점
- 반드시 하나의 부모 태그로 감싸야 한다.
    ```jsx
    // 오류 발생
    return (
      <h1>제목</h1>
      <p>내용입니다.</p>
    )

    // 정상 동작
    return (
      <div>
        <h1>제목</h1>
        <p>내용입니다.</p>
      </div>
    )

    // 정상 동작 (fragment 사용)
    return (
      <>
        <h1>제목</h1>
        <p>내용입니다.</p>
      </>
    )
    ```
- JSX 중괄호 안에는 표현식(express)만 사용가능, 문(statement)는 사용불가)
    ```jsx
    // 오류 발생 - if문은 JavaScript statement다.
    { if (isLogin) { (<p>환영합니다.</p>) }}

    // 정상 동작 - 삼항 연산자 또는 && 연산자 사용
    { lsLogin ? (<p>환영합니다.</p>) : (<p>로그인하세요.</p>)}
    { isLogin && (<p>환영합니다.</p>) }
    ```
- `class` 대신 `className`을 사용
    ```jsx
    // html의 class는 JSX에서 예약어이기 때문에 className으로 사용한다.

    // 오류 발생
    <div class="container"></div>

    // 정상 동작
    <div className="container"></div>
    ```
- 속성 갑은 문자열이 아니면 반드시 중괄호 사용
    ```jsx
    <input type="text" maxLength={10} />
    <MyComponent visible={true} />
    ```
- 함수 내에서 JSX 반환시 `return` 구문 작성시 주의
    ```jsx
    // 올바르지 않는 예시 : return문 다음 줄바꿈 시 undefined 반환
    return
      <h1>제목</h1>

    // 올바른 예시
    return (
      <h1>제목</h1>
    )
    ```
- JSX 내 반복은 `map()` 사용, `for`문은 사용 불가
    ```jsx
    // jsx 내부에서 for문 직접 사용 불가
    return (
      <div>
        for (let i = 0;  i < list.length; i++) {
          <p>{list[i].name}</p>
        }
      </div>
    )

    // map()을 사용
    return (
      <div>
        {list.map((item) => (
          <p>{item.name}</p>
        ))}
      </div>
    )
    
    ```
- 반복 요소에는 `key` 속성 필수 : `key`는 UI를 업데이트할 때 어떤 요소가 추가, 삭제, 재사용되어야 하는지 판단할 때 고유 식별자 역할을 한다.
    ```jsx
    // 올바른 key 예시
    // emp.id와 같이 고유하고 변하지 않는 값을 key로 사용해야 한다.
    const employees = [
      {id:102, name:"홍길동", dept:"영업부"},
      {id:107, name:"김유신", dept:"기술부"},
      {id:121, name:"강감찬", dept:"경리팀"}
    ];
    function App() {
      return (
        <table>
          {employees.map(emp => (
            <tr key={emp.id}>
              <td>{emp.id}</td>
              <td>{emp.name}</td>
              <td>{emp.dept}</td>
            </tr>
          ))}
        </table>
      )
    }
    
    // 잘못된 key 예시
    // index값을 key로 사용하면 반복 중 항목이 추가/삭제될 때 렌더링 오류나 상태 유지 문제가 발생할 수 있다.
    const employees = [
      {id:102, name:"홍길동", dept:"영업부"},
      {id:107, name:"김유신", dept:"기술부"},
      {id:121, name:"강감찬", dept:"경리팀"}

    function App() {
      return (
        <table>
          {employees.map((emp, index) => (
            <tr key={index}>
              <td>{emp.id}</td>
              <td>{emp.name}</td>
              <td>{emp.dept}</td>
            </tr>
          ))}
        </table>
      )
    }
    ```
- `style`은 문자열이 아닌 객체로 작성
    ```jsx
    // 올바르지 않은 예시
    <div style="color: red; font-size: 14px;"></div>

    // 올바른 예시
    <div style={{ color: 'red', fontSize: '14px' }}></div>
    ```
- 주석은 `{/* */}` 형식으로 작성
    ```jsx
    funtion App() {
      return (
        <div>
          {/* 주석입니다. */}
          <h1>제목</h1>
        </div>
      );
    }
    ```
- 이벤트 핸들링 - 카멜케이스 이벤트 이름과 함수 전달 방식을 사용한다.
    ```jsx
    // 함수 참조 전달하기
    function App() {
      const handClick = () => {
        alert("버튼이 클릭되었습니다.");
      };
      return (
        <button onClick={handClick}>버튼</button>
      )
    }

    // 화살표 함수 직접 전달
    function App() {
      return (
        <button onClick={() => alert("버튼이 클릭되었습니다.")}>
      )
    }

    // 이벤트 객체 사용
    function App() {
      const handClick = (e) => {
        console.log('이벤트 객체:', e);
        console.log('이벤트가 발생한 요소:', e.target);
      };
      return (
        <button onClick={handClick}>버튼</button>
      )
    }

    // 매개변수 있는 이벤트 핸들러
    // onClick={handleClick('홍길동')} 처럼 작성하면 이벤트 발생여부와 상관없이 UI 렌더링 시 바로 실행되어 버림
    function App() {
      const handClick = (name) => {
        alert(name + "님 환영합니다.");
      };
      return (
        <button onClick={() => handleClick('홍길동')}>버튼</button>
      )
    }
    ```

## 개발하기
### 인사말 출력하기
```jsx
// App.jsx 
const App = () => {
  return (
    <div>
      <h1>안녕하세요</h1>
    </div>
  );
};
export default App;
```

```jsx
// main.jsx
import { createRoot } from 'react-dom/client';
import App from './App.jsx';

createRoot(document.getElementById('root')).render(<App />);
```

### 데이터 표현하기
#### 변수값 렌더링
```jsx
// App.jsx
const App = () => {
  const name = "홍길동";
  return (
    <div>
      <h1>안녕하세요, {name}님!</h1>
    </div>
  );
}
```

#### 객체 데이터 렌더링
```jsx
// App.jsx
const App = () => {
  const user = { name:"홍길동", age:25};
  return (
    <div>
      <p>이름: {user.name}</p>
      <p>나이: {user.age}</p>
    </div>
  );
}
```

#### 배열 데이터 렌더링
```jsx
// App.jsx
const App = () => {
  const employees = [{no:1, name:"홍길동", dept:"영업팀"}, {no:2, name:"김유신", dept:"경리부"}];
  return (
    <div>
      <h1>직원 목록</h1>
      <table>
        <thead>
          <tr>
            <th>번호</th>
            <th>이름</th>
            <th>부서명</th>
          </tr>
        </thead>
        <tbody>
          {employees.map((emp) => (
            <tr key={emp.no}>
              <td>{emp.no}</td>
              <td>{emp.name}</td>
              <td>{emp.detp}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}
// 배열을 map() 함수로 순회하며 JSX 엘리먼트를 생성한다.
// 각 항목에는 고유한 key 속성을 부여한다.
```

#### 조건부 데이터 렌더링
```jsx
// App.jsx
const App = ({ isLogined }) => {
  return (
    <div>
      <ul>
        <li>홈</li>
        {isLogined && (
          <li>게시글</li>
        )}
        {isLogined ? (
          <li>로그아웃</li>
        ) : (
          <>
            <li>로그인</li>
            <li>회원가입</li>
          </>
        )}
      </ul>
    </div>
  )
}
// {isLogined && (isLogined가 true로 판정될 때 렌더링된다)}
// {isLogined ? (isLogined가 true로 판정될 때 렌더링된다) : (isLogined가 false로 판정될 때 렌더링된다)}
```

### useState로 컴포넌트의 상태관리
```jsx
// App.jsx
import { useState } from 'react';

const App () => {
  const [count, setCount] = useState(0);
  const handleEvent = (e) => {
    setCount(count + 1);
  }

  return (
    <div>
      <p>클릭 횟수: {count}</p>
      <button onClick={handleEvent}>클릭</button>
    </div>
  )
}
// useState(0)은 초기값 0으로 상태를 선언하는 React Hook이다.
//   useState()함수는 배열을 반환하며, 첫번째 요소는 현재 상태값, 두번째 요소는 상태를 갱신하는 함수
//   [count, setCount]는 구조 분해할당을 통해 상태변수와 상태변경 함수를 각각 할당하낟.
// count는 현재 상태값을 담는 변수다.
// setCount는 상태값을 변경하는 함수다, setCount()함수를 실행해서 상태값을 변경하면 화면이 다시 렌더링된다.
```

### Props로 값 전달
```jsx
// App.jsx
const App = () => {
  return (
    <div>
      <Greeting name="홍길동" />
      <Greeting name="김유신" />
    </div>
  );
}
// <Greeting name="홍길동" />는 Greeting 컴포넌트에 name이름으로 "홍길동"을 전달한다.
// Greeting에서는 props객체를 데이터를 전달받는다.
```

```jsx
// Greeting.jsx
const Greeting = (props) => {
  return (
    <p>반갑습니다. {props.name}</p>
  )
}
// props는 부모 컴포넌트가 자식 컴포넌트로 전달한 데이터를 표현하는 객체다.
//   props.name으로 전달받는 값을 표현한다.
```

```jsx
// Greeting.jsx
const Greeting = ({ name }) => {
  return (
    <p>반갑습니다. {name}</p>
  )
}
// ({ name })은 props객체의 데이터를 구조 분해 할당 방식으로 작성한 것이다.
```
