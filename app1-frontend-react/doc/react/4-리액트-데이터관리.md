# Props와 State
- `Props`와 `State`는 리액트 컴포넌트에서 데이터를 다루는 핵심 개념이다.
- `Props`는 부모 컴포넌트에서 자식 컴포넌트로 전달되는 읽기 전용 데이터다.
- `State`는 컴포넌트 내부에서 관리되는 변경 가능한 데이터다.

```perl
[Data ↓]
   - 부모 컴포넌트에서 자식 컴포넌트로 Props를 통해 데이터 전달
   - 단방향 데이터 흠
[State]
   - 각 컴포넌트 내부
   - 각 컴포넌트는 자신만의 State를 가질 수 있음
   - State 변경 시 해당 컴포넌트와 하위 컴포넌트는 리렌더링된다. 
[Events ↑]
   - 자식 -> 부모로 이벤트 전달
   - 콜백 함수를 통해 상위 컴포넌트의 상태 변경

       ┌───────────────────────────┐
       │       Component           │
       │        (state)            │
       └───────────────────────────┘
            /               \
      props/                 \props
         /                     \
┌─────────────────┐     ┌─────────────────┐
│   Component     │     │   Component     │
│    (state)      │     │    (state)      │
└─────────────────┘     └─────────────────┘
                           /           \
                     props/             \props
                        /                 \
         ┌─────────────────┐     ┌─────────────────┐
         │   Component     │     │   Component     │
         │    (state)      │     │    (state)      │
         └─────────────────┘     └─────────────────┘

```

## Props
- `Props`는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하기 위한 매커니즘이다.
- 기본 개념
  - **데이터 전달**
    - `Props`는 부모 컴포넌트가 자식 컴포넌트에게 어떤 값(문자열, 숫자, 불린, 객체, 배열, 함수 등)을 전달 할 수 있도록 한다.
  - **읽기 전용**
    - `Props`는 불변(immutable)이다. 자식 컴포넌트 내에서는 전달받은 `Props`의 값을 직접 변경할 수 없다.
    - 자식 컴포넌트가 부모 컴포넌트로부터 전달 받은 데이터를 변경해야 한다면, 부모 컴포넌트에게 해당 데이터를 변경하는 함수를 `Props`로 전달받아 호출하는 방식으로 처리해야 한다.
  - **단방향 데이터 흐름**
    - 데이터는 항상 부모 컴포넌트에서 자식 컴포넌트으로만 전달된다.
- 예시
  - `Props`로 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하고, 자식 컴포넌트에서 사용하기
    ```jsx
    // 부모 컴포넌트
    const ParentComponent = () => {
      const userName = "홍길동";
      const userAge = 30;
      return (
        <div>
          {/* ChildComponent에게 userName변수의 값을 name이라는 Props로 전달 */}
          {/* ChildComponent에게 userAge변수의 값을 age이라는 Props로 전달 */}
          <ChildComponent name={userName} age={userAge}/>

          {/* ChildComponent에게 문자열 "김유신"을 name이라는 Props로 전달 */}
          {/* ChildComponent에게 숫자 50을 age이라는 Props로 전달 */}
          <ChildComponent name="김유신" age={50}/>
        </div>
      );
    }
    export default ParentComponent;
    ```
    
    &#x2B07; `ChildComponent`를 호출(렌더링)하면 다음과 같이 `Props`가 전달된다. `Props`는 객체의 형태다.

    ```javascript
    // 첫번째 ChildComponent에게 전달되는 Props 객체
    props = {
      name: "홍길동",
      age: 30
    }
    ```
    
    &#x2B07; `ChildComponent`에서는 "Props" 라는 매개변수로 `Props`객체를 전달받는다. 
    
    ```jsx
    // 첫번째 자식 컴포넌트
    const ChildComponent = (props) => {
      return (
        <div>
          {/* 자식 컴포넌트에서는 props.name, props.age로 전달받은 데이터를 표현한다. */}
          <p> 이름: {props.name}</p>
          <p> 나이: {props.age}</p>
        </div>
      )
    }
    export default ChildComponent;
    ```
    
  - 자식 컴포넌트에서 비구조화할당으로 `Props` 전달받기
    // 두번째 ChildComponent에게 전달되는 Props 객체
    ```javascript
    props = {
      name: "김유신",
      age: 50
    }
    ```
   
    &#x2B07; 자식 컴포넌트에서 비구조화할당으로 `Props`객체의 값을 전달받는다. `{ name, age } = { name:"김유신", age:50 }`

    ```java
    // 두번째 자식 컴포넌트
    const ChildComponent = ({ name, age }) => {
      return (
        <div>
          {/* 자식 컴포넌트에서는 name, age로 전달받은 데이터를 표현한다. */}
          <p> 이름: {name}</p>
          <p> 나이: {age}</p>
        </div>
      )
    }
    export default ChildComponent;
    ```
    
   - 특별한 Props: `children`
     - `children`은 해당 컴포넌트의 여는 태그와 닫는 태그 사이에 있는 내용을 전달받을 때 사용되는 특별한 `Props`다.
      ```jsx
      // Card 컴포넌트의 내부에 렌더링되는 컨텐츠를 포함하는 컴포넌트
      const Main = () => {
        return (
          <div>
            <Card title="메인 페이지">
              <p>메인 페이지 방문을 환영합니다.</p>
              <div>
                <button>로그인</button>
                <button>회원가입</button>
              </div>
            </Card>
          </div>
        )
      } 
      ```

      &#x2B07; Main 컴포넌트에서 Card 컴포넌트로 전달되는 내용

      ```jsx
      props = {
        title:"메인 페이지",
        children: (
          <p>메인 페이지 방문을 환영합니다.</p>
          <div>
            <button>로그인</button>
            <button>회원가입</button>
          </div>
        )
      }
      ```

      &#x2B07; `Props`의 `title`과 `children`이 비구조화할당으로 Car컴포넌트에 전달된다.   

      ```jsx
      // Card 컴포넌트
      const Card = ({ title, children }) => {
        return (
          <div className="card">
            <div className="card-header">
              {title}
            </div>
            <div className="card-body">
              {/* Card 컴포넌트를 사용하는 곳의 컴포넌트 내부 내용이 이 위치에 렌더링된다. */}
              {children}
            </div>
          </div>
        )
      } 
      ```

      &#x2B07; 최종 렌더링 결과

      ```jsx
      <div>
        <div class="card>
          <div class="card-header">
            <!-- props의 title이 렌더링 -->
            메인 페이지
          </div>
          <div class="card-body">
            <!-- props의 chidren이 렌더링 -->
            <p>메인 페이지 방문을 환영합니다.</p>
            <div>
              <button>로그인</button>
              <button>회원가입</button>
            </div>
          </div>
        </div>
      </div>
      ```
## State
- `State`는 컴포넌트 내부에서 관리되는 동적인 데이터다.
- `Props`가 부모 컴포넌트로부터 전달받아 변경할 수 없는 데이터라면, `State`는 컴포넌트가 스스로 생성하고 관리하며, 시간에 따라 변경될 수 있는 데이터다.
- `State`의 변경은 컴포넌트의 렌더링을 트리거하며 UI를 업데이트하는 핵심 매커니즘이다.
- 기본 개념
  - **컴포넌트의 데이터 관리**
    - State는 해당 컴포넌트의 생명주기 동안 유지된다.
    - 해당 컴포넌트 내에서는 데이터에 자유롭게 접근하고 변경할 수 있다.
  - **동적 데이터**
    - State가 관리하는 데이터는 시간에 따라 변경될 수 있는 데이터다.
    - 예시
      - 사용자가 입력한 값: 입력필드의 값을 입력할 때 마다 값이 변경된다.
      - 서버에서 가져오는 데이터: 게시글 목록의 경우 페이지번호를 클릭할 때 마다 해당 페이지의 게시글 목록을 서버에서 다시 가져온다.
  - **변화에 따른 UI 업데이터**
    - State의 값이 변경되면 React는 해당 컴포넌트와 그 자식 컴포넌트들을 자동으로 다시 렌더링(re-render)하여 변경된 State값을 반영한다.
    - React가 선언적 UI을 구현하는 핵심 매커니즘이다.
  - **불변성**
    - State가 관리하는 데이터를 직접적으로 수정할 수 없다.
    - State 업데이트 함수(함수형 컴포넌트의 `useState` 훅)를 사용하여 새로운 State 객체를 반환한다.
- **함수형 컴포넌트에서의 State (`useState` 훅)**
  - 함수형 컴포넌트에서 State는 React Hook 중 하나인 `useState` 훅을 사용하여 관리한다.
  - 예시
    ```jsx
    import React, { useState } from 'react';
    
    const Counter = () => {
      // 1. State 선언 : useState 훅을 호출하여 State변수와 State를 업데이트하는 함수를 반환받는다.
      //    useState(초기값)를 실행하면 useState함수는 [현재state값, state업데이트함수]가 포함된 배열을 반환한다.
      //    아래의 수행문이 실행되면
      //        변수 count에는 State의 현재 상태값 0 대입된다.
      //        변수 setCount에는 State값을 업데이트하는 함수가 대입된다.
      const [count, setCount] = useState(0);

      // 2. State 변경 : State 업데이트 함수를 사용해서 State를 변경한다.
      const handleIncrement = () => {
        // 현재 count값에 1을 더한 새로운 값으로 State를 직접 설정한다.
        setCount(count + 1);
      }
      const handleDecrement = () => {
        // 이전 상태값(prevCount)을 안전하게 참조하여 변경하는 업데이트 함수를 전달해서 State 값을 변경한다.
        setCount(prevCount => prevCount - 1);
      }

      return (
        <div>
          <h1>함수형 State 실습 예제</h1>
          <p>카운트값 : {count}</p>

          <div>
            <button onClick={handleIncrement}>증가</button>
            <button onClick={handleDecrement}>감소</button>
          </div>
        </div>
      );
    }
    ```
- **State 사용시 중요 원칙**
  - **불변성 유지**
    - **절대로 State를 직접 수정하지 마라**
    - 항상 State업데이트 함수를 사용하라
    - 객체나 배열을 업데이트할 때는 전개 연산자나 map, filter 메소드를 사용해서 새로운 객체/배열을 생성해야 한다.
    - 예시
      ```jsx
      // State 선언
      const [count, setCount] = useState(0);
      const [user, setUser] = useState({ name:"홍길동", age:30 });
      const [depts, setDepts] = useState(["영업부", "기술부"]);

      // 올바르지 않은 업데이트
      const incrementCount = () => {
        count++;
      }
      
      const updateUserName = () => {
        user.name = "강감찬";
      }
      
      const addDept = (newDept) => {
        depts.push(newDept);
      }

      
      // 올바른 업데이트 - 숫자, 문자열, 불린값과 같은 단순한 값 업데이트
      const incrementCount = () => {
        // 첫번째 방법
        // setCount(새로운값)에 새로운 값을 전달해서 호출한다.
        setCount(count + 1);

        // 두번째 방법
        // setCount(업데이트함수)에 이전 상태값을 참조해서 업데이트하는 함수를 전달하고 호출한다.
        setCount(prevCount => prevCount + 1);
      }
      
      // 올바른 업데이트 - 객체형식의 값 업데이트
      const updateUserName = () => {
        // 첫번째 방법
        // 전개연산자로 객체의 기존 속성값을 복사하고, name 속성만 변경된 새로운 객체를 생성해서
        // setUser(새객체)에 새로 생성된 객체를 전달하고 호출한다.
        setUser({...user, name:"강감찬"})

        // 두번째 방법
        // setUser(업데이트함수)에 이전 상태값을 참조해서 업데이트하는 함수를 전달하고 호출한다.
        // 업데이트함수는 객체의 기존 상태를 전개연산자로 복사하고, name 속성을 "강감찬"으로 업데이트한 새로운 객체를 반환한다.
        setUser(prevUser => (
          {...prevUser, name:"강감찬"}
        ))
      }
      
      // 올바른 업데이트 : 배열에 새로운 요소 추가
      const addDept = (newDept) => {
        // 첫번째 방법
        // 전개연산자로 배열의 모든 요소를 복사하고, newDept가 추가된 새로운 배열을 생성해서
        // setDepts(새배열)에 새로 생성된 배열을 전달하고 호출한다.
        setDepts([...depts, newDept]);
      
        // 두번째 방법
        // setDepts업데이트함수)에 이전 상태값을 참조해서 업데이트하는 함수를 전달하고 호출한다.
        // 업데이트함수는 배열의 기존 상태를 전개연산자로 복사하고, newDept가 추가된 배열을 반환한다.
        setDepts(prevDepts => [...prevDepts, newDept]);
      }
      
      // 올바른 업데이트 : 배열에서 요소 삭제
      const removeDept = (dept) => {
        // 첫번째 방법
        // 배열의 fiter메소드가 전달받은 dept와 일치하지 않는 요소로만 구성된 새로운 배열을 생성하고
        // setDepts(새배열)에 새로 생성된 배열을 전달하고 호출한다.
        setDepts(depts.filter(item => item !== dept)));
      
        // 두번째 방법
        // setDepts업데이트함수)에 이전 상태값을 참조해서 업데이트하는 함수를 전달하고 호출한다.
        // 업데이트함수는 배열의 fiter메소드가 전달받은 dept와 일치하지 않는 요소로만 구성된 새로운 배열을 반환한다.
        setDepts(prevDepts => prevDepts.filter(item => item !== dept));
      }
      ```  
  - **State는 오직 State를 소유한 컴포넌트만 수정할 수 있다.**
    - 다른 컴포넌트에서는 State값을 수정할 수 없다.
    - 자식 컴포넌트에서 부모 컴포넌트의 State값을 변경하려면, 부모 컴포넌트의 State값을 변경하는 함수를 Props로 자식 컴포넌트에게 전달해야 한다.
    - 예시
      ```jsx
      // 부모 컴포넌트
      const ParentComponent = () => {
        const [name, setName] = useState("홍길동");

        return (
          <div>
            <ChildComponent onNameChange={setName} />
          </div>
        );
      }
      ```
   
      &#x2B07; 자식 컴포넌트로 전달되는 Props

      ```javascript
      props = {
        onNameChange: setName함수
      }
      ```
   
      &#x2B07; 자식 컴포넌트는 비구조화할당으로 Props값을 가져온다.
      
      ```
      // 자식 컴포넌트
      const ChildComponent = ({ onNameChange }) => {
        const updateName = () => {
          // onNameChange에 setName함수가 대입되어 있으므로
          // onNameChange("강감찬") -> setName("강감찬")이다.
          // 즉, 자식 컴포넌트에서는 부모 컴포넌트의 State를 변경할 수 있는 함수를 전달받아서
          // 간접적으로 부모 컴포넌트의 State를 변경할 수 있다.
          onNameChange("강감찬");
        }
        <button onClick={updateName}>이름변경</button>
      }
      ```
  - **State 업데이트는 비동기적일 수 있다**
    - State값의 수정은 비동기방식으로 실행되기 때문에 업데이트된 State에 의존하여 다른 작업을 수행해야 한다면 `useEffect`훅을 사용해야 한다.
  - **State의 최소화**
    - State는 필요한 최소한의 데이터만 관리하는 것이 좋다.

## State vs. Props

| 항 | State | Props |
|---|---|---|
| **정의** | 컴포넌트 내부에서 관리되는 데이터, **시간에 따라 변할 수 있는 동적 데이터**다. | 부모 컴포넌트가 자식 컴포넌트에 전달하는 **읽기 전용 데이터**다.|
| **사용목적** | 사용자와 상호작용으로 변경되는 데이터를 저장 | 부모 컴포넌트에서 자식 컴포넌트에 데이터 전달용으로 사용 |
| **소유자** | 해당 State르 **선언하고 관리하는 컴포넌트** 자신이다. | 데이터를 **전달하는 부모 컴포넌트**다. |
| **가변성** | **가변적**이다. 해당 컴포넌트 내부에서 업데이트될 수 있다. | **불변적(읽기 전용)** 이다. 자식 컴포넌트에서는 전달받은 Props를 직접 변경할 수 없다.|
| **업데이트** | `useState`훅의 업데이트함수를 통해 **명시적으로 변경**한다. State가 변경되면 해당 컴포넌트와 그 자식 컴포넌트가 다시 렌더링된다. | 부모 컴포넌트에서 전달하는 Props의 값이 변경되면, 해당 Props를 전달받은 자식 컴포넌트가 **자동으로 다시 렌더링**된다.|
| **데이터흐름** | 주로 해당 **컴포넌트의 내부**에서 관리되며, 외부로 직접 전달되지 않는다. | **단방향(부모 컴포넌트 -> 자식 컴포넌트) 데이터 흐름**으로만 데이터가 흐른다. |

