# 리액트 컴포넌트 (Component)

## 컴포넌트 정의
### 정의
- 컴포넌트는 UI를 구성하는 재사용 가능한 단위다.
- 마크업(렌더링 결과), 스타일, 동작(로직/이벤트), 상태(state)를 하나의 단위로 캡슐화하여 재사용/조합/테스트 가능하게 만든다.
- 리액트에서는 컴포넌트가 함수 또는 클래스 형태로 표시되며, **Props**를 통해 외부 데이터를 전달받고, **State**로 내부 상태를 관리한다.

### 핵심원리 
- **단일 책임(Single Responsibility)** : 하나의 컴포넌트는 한 가지 역할에 충실
- **선언적(Declarative)** : 상태 -> UI의 매핑을 선언적으로 기술
- **재사용성/조합성(Composition)** : 작은 컴포넌트를 결합하여 큰 UI를 구성
- **계층적 데이터 흐름(top-down)** : 부모 -> 자식 Props 전달

## 컴포넌트의 종류
### 함수형 컴포넌트 (Function Component)
- 정의
  - Javascript 함수로 정의되는 컴포넌트
  - React **Hooks**(`useState`, `useEffect` 등)을 사용해 상태와 사이드 이펙트를 처리한다.
  - 코드가 간결하고, 테스트가 용이하다
  - React 16.8 이후 권장 방식(모든 기능 구현 가능)
- 특징
  - 구문: 일반 함수 형태 (`function` 또는 화살표 함수)
  - 상태관리: `useState`, `useReducer` 등 Hook 사용
  - 라이프사이클: `useEffect`(mount, update, unmount)로 통합 관리
  - this 사용: 없음
  - 성능: 가볍고 함수 호출 기반이기 때문에 최적화가 용이

- 예제
    ```jsx
    import React, { useState, useEffect } from 'react';

    const Counter = () => {
      // useState로 상태 정의
      const [count, setCount] = useState(0);

      // 이벤트 핸들러 함수 정의
      const handleIncrement = () => {
        setCount(count + 1);
      }

      // 사이드 이펙트 처리
      useEffect(() => {
        console.log('컴포넌트 마운트 또는 count 변경');
        return () => console.log('컴포넌트 언마운트');
      }, [count]); // count가 변경될 때마다 실

      return (
        <div>
          <h1>함수형 컴포넌트 예제</h1>
          <p>현재 카운트 : {count}</p>
          <button onClick={handleIncrement}>증가</button>
        </div>
      )
    }

    export default Counter;
    ```
### 클래스형 컴포넌트 (Class Component)
- 정의
  - ES6 클래스 문법을 사용해 React.Component를 상속하여 작성.
  - 상태(`this.state`)와 라이프사이클 메서드(`componentDidMount`, `componentDidUpdate` 등)를 사용.
- 특징
  - 구문: ES6 클래스 (`class ... extends React.Component`)
  - 상태관리: `this.state`와 `this.setState()` 사용
  - 라이프사이클: `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 등 명시적 메서드
  - this 사용: 이벤트핸들러 함수에서 `this` 바인딩 필요
  - 성능: 함수형 컴포넌트 대비 더 무겂다.
- 예제
    ```jsx
    import React, { Component } from 'react';

    class Counter extends Component {
      // 생성자 메소드 정의
      constructor(props) {
        super(props);
        // 상태 정
        this.state = { count: 0 };
      }

      // 라이프사이클 메소드 사용
      componentDidMount() {
        console.log('컴포넌트 마운트됨');
      }
      componentWillUnmount() {
        console.log('컴포넌트 언마운트됨');
      }

      // 이벤트 핸들러 함수 정의
      increment = () => this.setState(prev => ({ count: prev.count + 1}));

      render() {
        return (
          <div>
            <h1>클래스형 컴포넌트 예제</h1>
            <p>현재 카운트 : {this.state.count}</p>
            <button onClick={this.increment}>증가</button>
          </div>
        )
      }
    }
    ```

### 실무 관점 사용 가이드
- **신규 프로젝트**: 함수형 컴포넌트 + Hooks 사용.
- **기존 레거시 코드 유지보수**: 클래스형을 그대로 사용하되, 필요 시 점진적으로 함수형으로 리팩토링.

## 컴포넌트의 합성
컴포넌트 합성은 여러 개의 작고 단순한 컴포넌트들을 조합하여 복잡한 UI를 만드는 React의 핵심 원칙이다.

### 포함(Containment)
- **포함(Containment)** 은 부모 컴포넌트가 자식 컴포넌트를 감싸서 내부 콘텐츠를 렌더링하는 방식이다.
- 부모 컴포넌트는 자식 컴포넌트의 내용을 알지 못하고, props.children을 통해 전달받아 그대로 렌더링한다.
- 특징
  - `props.children`을 사용해 일반적인 "래퍼(Wrapper)" 컴포넌트를 만들 때 유용하다.
  - 부모 컴포넌트는 자식 컴포넌트의 내용에 대해 신경 쓸 필요가 없어 재사용성이 높다
- 구조
    ```perl
    // Containment는 부모 컴포넌트가 자식 컴포넌트를 감싸는 방식으로, 자식 컴포넌트의 내용을 props.children을 통해 렌더링한다.
    // 이는 범용적인 "Wrapper" 컴포넌트를 만들 때 유용합니다.
    
    ┌─────────────────────────────────────────────────┐
    │   Wrapper Component                             │
    │─────────────────────────────────────────────────│
    │   function Wrapper({ children }) {              │
    │     return (                                    │
    │       <div className="wrapper">                 │
    │         {children}                              │
    │       </div>                                    │
    │     );                                          │
    │   }                                             │
    └─────────────────────────────────────────────────┘
             │
             │ 렌더링 시
             ▼
    ┌─────────────────────────────────────────────────┐
    │   App Component                                 │
    │─────────────────────────────────────────────────│
    │   <Wrapper>                                     │
    │     <ChildA />                                  │
    │     <ChildB />                                  │
    │   </Wrapper>                                    │
    └─────────────────────────────────────────────────┘
    ```
- 예시
  - **Dialog** 컴포넌트: 모든 다이얼로그가 공통적으로 가지는 스타일이나 기능을 제공하고, 내용은 props.children으로 받는다.
    ```jsx
    // Dialog 컴포넌트 선언
    const Dialog = ({ childre }) => {
      return (
        <div className="dialog-frame">
          {children}
        </div>
      )
    }

    // Dialog 컴포넌트의 사용
    const App = () => {
      return (
        <div>
          <h1>컴포넌트 합성 연습</h1>
          <Dialog>
            <h3>환영합니다</h3>
            <p>이것은 포함 패턴의 예시입니다.</p>
          </Dialog>
        </div>
      );
    }
    ```
  
### 특수화(Specialization)
- **특수화(Specialization)** 는 특정 컴포넌트를 재사용하면서 일부 기능을 변경하거나 추가하여 새로운 컴포넌트를 만드는 방식이다
- 부모 컴포넌트가 자식 컴포넌트에 특정 props를 전달하여 동작을 특수화시키는 방법으로 구현된다.
- 특징
  - 범용적인 컴포넌트에 특정 로직이나 스타일을 적용할 때 사용
  - 자식 컴포넌트의 유연성을 높여준다.
- 구조
    ```perl
    // Specialization은 범용적인 컴포넌트에 특정 기능을 추가하여 새로운 컴포넌트를 만드는 방법이다.
    // 부모 컴포넌트가 자식 컴포넌트에게 특정 데이터를 props로 전달하여 자식 컴포넌트의 동작을 특수화시킨다.
    
    ┌─────────────────────────────────────────────────┐
    │   App Component                                 │
    │─────────────────────────────────────────────────│
    │   const data = ['A', 'B', 'C'];                 │
    │   <List items={data} />                         │
    └─────────────────────────────────────────────────┘
              │
              │ props 전달
              ▼
    ┌─────────────────────────────────────────────────┐
    │   Generic Component                             │
    │─────────────────────────────────────────────────│
    │   function List({ items }) {                    │
    │     return (                                    │
    │       <ul>                                      │
    │         {items.map(item => <li>{item}</li>)}    │
    │       </ul>                                     │
    │     );                                          │
    │   }                                             │
    └─────────────────────────────────────────────────┘
    ```
- 예시
  - **Button** 컴포넌트: `variant` 같은 `Props`를 받아 기본 버튼의 스타일을 **특수화**하여 `primary`, `secondary` 등의 버튼을 만듭니다.
    ```jsx
    // Button 컴포넌트 선언
    const Button = ({ variant, children }) => {
      return (
        <Button className={`btn-${variant}`}>
          {children}
        </Button>
      )
    }

    // Button 컴포넌트 사용
    const App = () => {
      return (
        <div>
          <h1>컴포넌트 합성 연습</h1>

          <Button variant="primary">버튼1</Button>
          <Button variant="secondary">버튼2</Button>
          <Button variant="warning">버튼3</Button>
          <Button variant="danger">버튼4</Button>
        </div>
      );
    }
    ```
