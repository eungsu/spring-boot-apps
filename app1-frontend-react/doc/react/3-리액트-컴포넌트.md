# 리액트 컴포넌트 (Component)

## 컴포넌트 정의
### 정의
- 컴포넌트는 UI를 구성하는 재사용 가능한 단위다.
- 마크업(렌더링 결과), 스타일, 동작(로직/이벤트), 상태(state)를 하나의 단위로 캡슐화하여 재사용/조합/테스트 가능하게 만든다.
- 리액트에서는 컴포넌트가 함수 또는 클래스 형태로 표시되며, **Props**를 통해 외부 데이터를 전달받고, **State**로 내부 상태를 관리한다.

### 핵심원리 
- **단일 책임(Single Responsibility)** : 하나의 컴포넌트는 한 가지 역할에 충실
- **선언적(Declarative)** : 상태 -> UI의 매핑을 선언적으로 기술
- **재사용성/조합성(Composition)** : 작은 컴포넌트를 결합하여 큰 UI를 구성
- **계층적 데이터 흐름(top-down)** : 부모 -> 자식 Props 전달

## 컴포넌트의 종류
### 함수형 컴포넌트 (Function Component)
- 정의
  - Javascript 함수로 정의되는 컴포넌트
  - React **Hooks**(`useState`, `useEffect` 등)을 사용해 상태와 사이드 이펙트를 처리한다.
  - 코드가 간결하고, 테스트가 용이하다
  - React 16.8 이후 권장 방식(모든 기능 구현 가능)
- 특징
  - 구문: 일반 함수 형태 (`function` 또는 화살표 함수)
  - 상태관리: `useState`, `useReducer` 등 Hook 사용
  - 라이프사이클: `useEffect`(mount, update, unmount)로 통합 관리
  - this 사용: 없음
  - 성능: 가볍고 함수 호출 기반이기 때문에 최적화가 용이
- 예제
    ```jsx
    import React, { useState, useEffect } from 'react';

    const Counter = () => {
      // useState로 상태 정의
      const [count, setCount] = useState(0);

      // 이벤트 핸들러 함수 정의
      const handleIncrement = () => {
        setCount(count + 1);
      }

      // 사이드 이펙트 처리
      useEffect(() => {
        console.log('컴포넌트 마운트 또는 count 변경');
        return () => console.log('컴포넌트 언마운트');
      }, [count]); // count가 변경될 때마다 실

      return (
        <div>
          <h1>함수형 컴포넌트 예제</h1>
          <p>현재 카운트 : {count}</p>
          <button onClick={handleIncrement}>증가</button>
        </div>
      )
    }

    export default Counter;
    ```
### 클래스형 컴포넌트 (Class Component)
- 정의
  - ES6 클래스 문법을 사용해 React.Component를 상속하여 작성.
  - 상태(`this.state`)와 라이프사이클 메서드(`componentDidMount`, `componentDidUpdate` 등)를 사용.
- 특징
  - 구문: ES6 클래스 (`class ... extends React.Component`)
  - 상태관리: `this.state`와 `this.setState()` 사용
  - 라이프사이클: `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 등 명시적 메서드
  - this 사용: 이벤트핸들러 함수에서 `this` 바인딩 필요
  - 성능: 함수형 컴포넌트 대비 더 무겂다.
- 예제
    ```jsx
    import React, { Component } from 'react';

    class Counter extends Component {
      // 생성자 메소드 정의
      constructor(props) {
        super(props);
        // 상태 정
        this.state = { count: 0 };
      }

      // 라이프사이클 메소드 사용
      componentDidMount() {
        console.log('컴포넌트 마운트됨');
      }
      componentWillUnmount() {
        console.log('컴포넌트 언마운트됨');
      }

      // 이벤트 핸들러 함수 정의
      increment = () => this.setState(prev => ({ count: prev.count + 1}));

      render() {
        return (
          <div>
            <h1>클래스형 컴포넌트 예제</h1>
            <p>현재 카운트 : {this.state.count}</p>
            <button onClick={this.increment}>증가</button>
          </div>
          
        )
      }
    }
    ```

### 실무 관점 사용 가이드
- **신규 프로젝트**: 함수형 컴포넌트 + Hooks 사용.
- **기존 레거시 코드 유지보수**: 클래스형을 그대로 사용하되, 필요 시 점진적으로 함수형으로 리팩토링.
