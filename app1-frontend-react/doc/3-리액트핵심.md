# Props와 State
- `Props`와 `State`는 리액트 컴포넌트에서 데이터를 다루는 핵심 개념이다.
- `Props`는 부모 컴포넌트에서 자식 컴포넌트로 전달되는 읽기 전용 데이터다.
- `State`는 컴포넌트 내부에서 관리되는 변경 가능한 데이터다.

## Props
- `Props`는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하기 위한 매커니즘이다.
- 기본 개념
  - **데이터 전달**
    - `Props`는 부모 컴포넌트가 자식 컴포넌트에게 어떤 값(문자열, 숫자, 불린, 객체, 배열, 함수 등)을 전달 할 수 있도록 한다.
  - **읽기 전용**
    - `Props`는 불변(immutable)이다. 자식 컴포넌트 내에서는 전달받은 `Props`의 값을 직접 변경할 수 없다.
    - 자식 컴포넌트가 부모 컴포넌트로부터 전달 받은 데이터를 변경해야 한다면, 부모 컴포넌트에게 해당 데이터를 변경하는 함수를 `Props`로 전달받아 호출하는 방식으로 처리해야 한다.
  - **단방향 데이터 흐름**
    - 데이터는 항상 부모 컴포넌트에서 자식 컴포넌트으로만 전달된다.
- 예시
  - `Props`로 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하고, 자식 컴포넌트에서 사용하기
    ```jsx
    // 부모 컴포넌트
    const ParentComponent = () => {
      const userName = "홍길동";
      const userAge = 30;
      return (
        <div>
          {/* ChildComponent에게 userName변수의 값을 name이라는 Props로 전달 */}
          {/* ChildComponent에게 userAge변수의 값을 age이라는 Props로 전달 */}
          <ChildComponent name={userName} age={userAge}/>

          {/* ChildComponent에게 문자열 "김유신"을 name이라는 Props로 전달 */}
          {/* ChildComponent에게 숫자 50을 age이라는 Props로 전달 */}
          <ChildComponent name="김유신" age={50}/>
        </div>
      );
    }
    export default ParentComponent;
    ```
    
    &#x2B07; `ChildComponent`를 호출(렌더링)하면 다음과 같이 `Props`가 전달된다. `Props`는 객체의 형태다.

    ```javascript
    // 첫번째 ChildComponent에게 전달되는 Props 객체
    props = {
      name: "홍길동",
      age: 30
    }
    ```
    
    &#x2B07; `ChildComponent`에서는 "Props" 라는 매개변수로 `Props`객체를 전달받는다. 
    
    ```jsx
    // 첫번째 자식 컴포넌트
    const ChildComponent = (props) => {
      return (
        <div>
          {/* 자식 컴포넌트에서는 props.name, props.age로 전달받은 데이터를 표현한다. */}
          <p> 이름: {props.name}</p>
          <p> 나이: {props.age}</p>
        </div>
      )
    }
    export default ChildComponent;
    ```
    
  - 자식 컴포넌트에서 비구조화할당으로 `Props` 전달받기
    // 두번째 ChildComponent에게 전달되는 Props 객체
    ```javascript
    props = {
      name: "김유신",
      age: 50
    }
    ```
   
    &#x2B07; 자식 컴포넌트에서 비구조화할당으로 `Props`객체의 값을 전달받는다. `{ name, age } = { name:"김유신", age:50 }`

    ```java
    // 두번째 자식 컴포넌트
    const ChildComponent = ({ name, age }) => {
      return (
        <div>
          {/* 자식 컴포넌트에서는 name, age로 전달받은 데이터를 표현한다. */}
          <p> 이름: {name}</p>
          <p> 나이: {age}</p>
        </div>
      )
    }
    export default ChildComponent;
    ```
    
   - 특별한 Props: `children`
     - `children`은 해당 컴포넌트의 여는 태그와 닫는 태그 사이에 있는 내용을 전달받을 때 사용되는 특별한 `Props`다.
      ```jsx
      // Card 컴포넌트의 내부에 렌더링되는 컨텐츠를 포함하는 컴포넌트
      const Main = () => {
        return (
          <div>
            <Card title="메인 페이지">
              <p>메인 페이지 방문을 환영합니다.</p>
              <div>
                <button>로그인</button>
                <button>회원가입</button>
              </div>
            </Card>
          </div>
        )
      } 
      ```

      &#x2B07; Main 컴포넌트에서 Card 컴포넌트로 전달되는 내용

      ```jsx
      props = {
        title:"메인 페이지",
        children: (
          <p>메인 페이지 방문을 환영합니다.</p>
          <div>
            <button>로그인</button>
            <button>회원가입</button>
          </div>
        )
      }
      ```

      &#x2B07; `Props`의 `title`과 `children`이 비구조화할당으로 Car컴포넌트에 전달된다.   

      ```jsx
      // Card 컴포넌트
      const Card = ({ title, children }) => {
        return (
          <div className="card">
            <div className="card-header">
              {title}
            </div>
            <div className="card-body">
              {/* Card 컴포넌트를 사용하는 곳의 컴포넌트 내부 내용이 이 위치에 렌더링된다. */}
              {children}
            </div>
          </div>
        )
      } 
      ```

      &#x2B07; 최종 렌더링 결과

      ```jsx
      <div>
        <div class="card>
          <div class="card-header">
            <!-- props의 title이 렌더링 -->
            메인 페이지
          </div>
          <div class="card-body">
            <!-- props의 chidren이 렌더링 -->
            <p>메인 페이지 방문을 환영합니다.</p>
            <div>
              <button>로그인</button>
              <button>회원가입</button>
            </div>
          </div>
        </div>
      </div>
      ```
## State
- `State`는 컴포넌트 내부에서 관리되는 동적인 데이터다.
- `Props`가 부모 컴포넌트로부터 전달받아 변경할 수 없는 데이터라면, `State`는 컴포넌트가 스스로 생성하고 관리하며, 시간에 따라 변경될 수 있는 데이터다.
- `State`의 변경은 컴포넌트의 렌더링을 트리거하며 UI를 업데이트하는 핵심 매커니즘이다.
- 기본 개념
  - **컴포넌트의 데이터 관리**
    - State는 해당 컴포넌트의 생명주기 동안 유지된다.
    - 해당 컴포넌트 내에서는 데이터에 자유롭게 접근하고 변경할 수 있다.
  - **동적 데이터**
    - State가 관리하는 데이터는 시간에 따라 변경될 수 있는 데이터다.
    - 예시
      - 사용자가 입력한 값: 입력필드의 값을 입력할 때 마다 값이 변경된다.
      - 서버에서 가져오는 데이터: 게시글 목록의 경우 페이지번호를 클릭할 때 마다 해당 페이지의 게시글 목록을 서버에서 다시 가져온다.
  - **변화에 따른 UI 업데이터**
    - State의 값이 변경되면 React는 해당 컴포넌트와 그 자식 컴포넌트들을 자동으로 다시 렌더링(re-render)하여 변경된 State값을 반영한다.
    - React가 선언적 UI을 구현하는 핵심 매커니즘이다.
  - **불변성**
    - State가 관리하는 데이터를 직접적으로 수정할 수 없다.
    - State 업데이트 함수(함수형 컴포넌트의 `useState` 훅)를 사용하여 새로운 State 객체를 반환한다.
- **함수형 컴포넌트에서의 State (`useState` 훅)**
  - 함수형 컴포넌트에서 State는 React Hook 중 하나인 `useState` 훅을 사용하여 관리한다.
  - 예시
    ```jsx
    import React, { useState } from 'react';
    
    const Counter = () => {
      // 1. State 선언 : useState 훅을 호출하여 State변수와 State를 업데이트하는 함수를 반환받는다.
      //    useState(초기값)를 실행하면 useState함수는 [현재state값, state업데이트함수]가 포함된 배열을 반환한다.
      //    아래의 수행문이 실행되면
      //        변수 count에는 State의 현재 상태값 0 대입된다.
      //        변수 setCount에는 State값을 업데이트하는 함수가 대입된다.
      const [count, setCount] = useState(0);

      // 2. State 변경 : State 업데이트 함수를 사용해서 State를 변경한다.
      const handleIncrement = () => {
        // 현재 count값에 1을 더한 새로운 값으로 State를 직접 설정한다.
        setCount(count + 1);
      }
      const handleDecrement = () => {
        // 이전 상태값(prevCount)을 안전하게 참조하여 변경하는 업데이트 함수를 전달해서 State 값을 변경한다.
        setCount(prevCount => prevCount - 1);
      }

      return (
        <div>
          <h1>함수형 State 실습 예제</h1>
          <p>카운트값 : {count}</p>

          <div>
            <button onClick={handleIncrement}>증가</button>
            <button onClick={handleDecrement}>감소</button>
          </div>
        </div>
      );
    }
    ```
- **State 사용시 중요 원칙**
  - **불변성 유지**
  - **State는 오직 State를 소유한 컴포넌트만 수정할 수 있다.**
  - **State 업데이트는 비동기적일 수 있다**
  - **State의 최소화**
